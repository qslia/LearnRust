Great question ‚Äî **why do we wrap this section with `{}`?**

```rust
{
    let mut node = root_rc.borrow_mut();
    let left = node.left.take();
    let right = node.right.take();
    drop(node);
}
```

---

## ‚úÖ Purpose of `{}` ‚Üí Create a *temporary scope*

Rust's borrow checker cares about **when** a borrow ends.

`borrow_mut()` creates a mutable borrow of the `RefCell`:

```rust
let mut node = root_rc.borrow_mut();
```

This borrow lives until the variable `node` goes out of scope.

If we don‚Äôt wrap the code in `{}`, the borrow might last *longer than we want*, and we would not be allowed to call recursion afterward, because recursion tries to borrow the same node again.

So `{}` does this:

| Without `{}`                                | With `{}`                                      |
| ------------------------------------------- | ---------------------------------------------- |
| `node` stays borrowed until end of function | `node` is dropped once we leave the `{}` block |
| Recursive calls fail (borrow still active)  | Recursive calls succeed (borrow ended)         |

---

## üîç Why we must drop the borrow before recursion

If we do NOT use `{}`:

```rust
let mut node = root_rc.borrow_mut();
let left = node.left.take();
let right = node.right.take();

// ‚ùå BORROW STILL ACTIVE HERE
let inverted_left = Solution::invert_tree(left);
```

Rust will complain:

```
cannot borrow `root_rc` as immutable because it is also borrowed as mutable
```

Because `borrow_mut()` is still active when calling `invert_tree`.

---

## ‚úÖ With `{}` the borrow ends before recursion

```rust
{
    let mut node = root_rc.borrow_mut();
    let left = node.left.take();
    let right = node.right.take();
} // <-- node goes out of scope here (borrow ends)

// recursion happens AFTER borrow ended
let inverted_left = Solution::invert_tree(left);
```

Once we leave the `{}` block:

* `node` is dropped,
* The mutable borrow on the `RefCell` ends,
* Rust allows recursion safely.

---

## üìå TL;DR

| Reason                    | What `{}` does             |
| ------------------------- | -------------------------- |
| Limit borrow lifespan     | `node` gets dropped early  |
| Borrow checker friendly   | recursion can borrow again |
| Explicit lifetime control | reduces borrow conflicts   |

Think of `{}` as telling the compiler:

> **‚ÄúDrop this borrow NOW ‚Äî I need to borrow again later.‚Äù**

---

If you'd like, I can show you a version **without `{}`**, and demonstrate the compiler error you would get. Just say **"show error version"**.
