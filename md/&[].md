Great question â€” this is a **Rust reference / pattern-matching detail**.
Hereâ€™s the simple explanation:

---

# âœ… Why `for &p in &[2, 3, 5]`?

### The array literal

```rust
[2, 3, 5]
```

has the type:

```
[ i32 ; 3 ]
```

When you iterate with:

```rust
for p in &[2, 3, 5]
```

you are iterating over **references** to each element:

```
p: &i32
```

But you want `p` to be an `i32`, not a reference.

---

# âœ”ï¸ Adding `&` in the pattern *dereferences* automatically

```rust
for &p in &[2, 3, 5]
```

This means:

* The array gives you `&i32`
* The pattern `&p` matches that and extracts the value into `p`
* So now `p` has type `i32`

Equivalent to manually writing:

```rust
for p_ref in &[2, 3, 5] {
    let p = *p_ref;   // manual dereference
}
```

`for &p in ...` is just a cleaner way to do this.

---

# ğŸ” Summary

| Form                 | Type of p | Notes                                       |
| -------------------- | --------- | ------------------------------------------- |
| `for p in &[2,3,5]`  | `&i32`    | p is a reference                            |
| `for &p in &[2,3,5]` | `i32`     | p is the value (dereferenced automatically) |
| `for p in [2,3,5]`   | `i32`     | iterates by value (moves array)             |

---

# ğŸ’¡ Alternative (also valid)

If you don't want the `&` pattern:

```rust
for p in [2, 3, 5] {
    // p: i32
}
```

But this **moves** the array (fine for literals, but not if borrowed).

---

If you want, I can show you how this works for tuples, structs, and more complex patterns.

<br>

In Rust, **â€œmoving an arrayâ€** means *transferring ownership* of the whole array value into something else (like a loop).
After a move, you cannot use the original array anymore.

Letâ€™s break it down clearly.

---

# âœ… 1. Array on the stack is a **value**, not a reference

```rust
let arr = [2, 3, 5];
```

This allocates the full array on the stack:

```
arr: [i32; 3]
```

---

# âœ… 2. Looping **by value** moves the array

If you write:

```rust
for p in [2, 3, 5] {
    ...
}
```

You are iterating **by value**, which means Rust must create an iterator that *owns* the array.

So the array is **moved** into the loop iterator.

After this, you cannot use the array anymore, because its ownership was consumed.

---

# âŒ Example â€” this errors

```rust
let arr = [2, 3, 5];

for x in arr {
    println!("{x}");
}

println!("{:?}", arr); // ERROR: arr was moved
```

Rust error:

```
value borrowed here after move
```

Because the loop consumed (moved) the array.

---

# âœ… 3. Looping over a **reference** does NOT move the array

```rust
let arr = [2, 3, 5];

for &x in &arr {
    println!("{x}");
}

println!("{:?}", arr); // OK!
```

`&arr` = borrow the array
`for &x in &arr` = iterate over *references*, then destructure to the value

The array stays untouched.

---

# ğŸ” So how it relates to your original question?

You saw:

```rust
for &p in &[2, 3, 5]
```

`&[2,3,5]` â†’ creates a **reference** to the array
So the array is **not moved**

And `&p` in the pattern dereferences each `&i32` to `i32`.

---

# ğŸ§  Summary Table

| Syntax               | Moves array? | p type | Notes                          |
| -------------------- | ------------ | ------ | ------------------------------ |
| `for p in [2,3,5]`   | Yes          | `i32`  | array is moved into loop       |
| `for p in &[2,3,5]`  | No           | `&i32` | iterates references            |
| `for &p in &[2,3,5]` | No           | `i32`  | reference + auto-deref pattern |

---

If you want, I can also show how **moving** works with vectors (`Vec`), strings, structs, and `Option<T>`.
